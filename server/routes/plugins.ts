import express, { Request, Response } from 'express';
import fs from 'fs';
import crypto from 'crypto';
import path from 'path';
import { exec } from 'child_process';
import projectManager from '../services/projectManager';
import { parsePluginMetadata, type PluginMetadata } from './pluginMetadataParser';

const router = express.Router();
const runtimePath = path.join(__dirname, '..', 'runtime');

function pluginFileHash(filePath: string): string {
  const content = fs.readFileSync(filePath);
  return crypto.createHash('md5').update(content).digest('hex');
}

// GET /api/plugins - List plugins and their status
router.get('/', (req: Request, res: Response) => {
  try {
    const pluginsDir = path.join(projectManager.getJsPath(), 'plugins');
    if (!fs.existsSync(pluginsDir)) return res.json({ plugins: [], list: [] });

    // Read plugins.js for enabled list
    const pluginsJsPath = path.join(projectManager.getJsPath(), 'plugins.js');
    let pluginList: { name: string; status: boolean; description: string; parameters: Record<string, string> }[] = [];
    if (fs.existsSync(pluginsJsPath)) {
      const content = fs.readFileSync(pluginsJsPath, 'utf8');
      const match = content.match(/\$plugins\s*=\s*(\[[\s\S]*?\]);/);
      if (match) {
        try { pluginList = JSON.parse(match[1]); } catch {}
      }
    }

    // List all .js files in plugins/
    const files = fs.readdirSync(pluginsDir).filter(f => f.endsWith('.js')).map(f => f.replace('.js', ''));

    res.json({ files, list: pluginList });
  } catch (err: unknown) {
    res.status(500).json({ error: (err as Error).message });
  }
});

// GET /api/plugins/metadata - Parse plugin file comments for param metadata
// Query params: ?locale=ko (optional, for localized metadata)
router.get('/metadata', (req: Request, res: Response) => {
  try {
    const pluginsDir = path.join(projectManager.getJsPath(), 'plugins');
    if (!fs.existsSync(pluginsDir)) return res.json({});

    const locale = req.query.locale as string | undefined;
    const files = fs.readdirSync(pluginsDir).filter(f => f.endsWith('.js'));
    const result: Record<string, PluginMetadata> = {};

    for (const file of files) {
      const name = file.replace('.js', '');
      const content = fs.readFileSync(path.join(pluginsDir, file), 'utf8');
      result[name] = parsePluginMetadata(content, locale);
    }

    res.json(result);
  } catch (err: unknown) {
    res.status(500).json({ error: (err as Error).message });
  }
});

// PUT /api/plugins - Save plugin list
router.put('/', (req: Request, res: Response) => {
  try {
    const pluginsJsPath = path.join(projectManager.getJsPath(), 'plugins.js');
    const plugins = req.body as { name: string; status: boolean; description: string; parameters: Record<string, string> }[];
    const lines = plugins.map(p => JSON.stringify(p));
    const content = `// Generated by RPG Maker.\n// Do not edit this file directly.\nvar $plugins =\n[\n${lines.join(',\n')}\n];\n`;
    fs.writeFileSync(pluginsJsPath, content, 'utf8');
    res.json({ success: true });
  } catch (err: unknown) {
    res.status(500).json({ error: (err as Error).message });
  }
});

// POST /api/plugins/open-folder - Open plugins folder in OS file explorer
router.post('/open-folder', (_req: Request, res: Response) => {
  try {
    const pluginsDir = path.join(projectManager.getJsPath(), 'plugins');
    const cmd = process.platform === 'darwin' ? `open "${pluginsDir}"`
      : process.platform === 'win32' ? `explorer "${pluginsDir}"`
      : `xdg-open "${pluginsDir}"`;
    exec(cmd);
    res.json({ success: true });
  } catch (err: unknown) {
    res.status(500).json({ error: (err as Error).message });
  }
});

// POST /api/plugins/open-vscode - Open plugin file in VSCode
// Body: { name: string }
// 프로젝트 js/plugins/<name>.js 를 우선하고, 없으면 에디터 런타임 plugins/<name>.js 를 연다.
router.post('/open-vscode', (req: Request, res: Response) => {
  try {
    const name = (req.body?.name as string || '').replace(/[^\w-]/g, '');
    if (!name) return res.status(400).json({ error: 'name required' });

    const projectFile = path.join(projectManager.getJsPath(), 'plugins', `${name}.js`);
    const runtimeFile = path.join(runtimePath, 'js', 'plugins', `${name}.js`);
    const filePath = fs.existsSync(projectFile) ? projectFile : runtimeFile;

    if (!fs.existsSync(filePath)) {
      return res.status(404).json({ error: `Plugin file not found: ${name}.js` });
    }

    const cmd = process.platform === 'darwin'
      ? `open -a "Visual Studio Code" "${filePath}"`
      : `code "${filePath}"`;
    exec(cmd, (err) => {
      if (err) {
        // fallback: try plain `code` command on macOS too
        exec(`code "${filePath}"`);
      }
    });
    res.json({ success: true, path: filePath });
  } catch (err: unknown) {
    res.status(500).json({ error: (err as Error).message });
  }
});

// Resolve a project-relative text file path safely
function resolveCreditFilePath(filePath: string): string | null {
  const basePath = projectManager.currentPath;
  if (!basePath) return null;
  const rel = filePath || 'data/Credits.txt';
  const resolved = path.resolve(path.join(basePath, rel));
  if (!resolved.startsWith(path.resolve(basePath))) return null; // path traversal guard
  return resolved;
}

// GET /api/plugins/credit-text?path=data/Credits.txt - Read credit text file
router.get('/credit-text', (req: Request, res: Response) => {
  try {
    const filePath = resolveCreditFilePath((req.query.path as string) || 'data/Credits.txt');
    if (!filePath) return res.status(403).json({ error: 'Access denied' });
    if (!fs.existsSync(filePath)) {
      return res.type('text/plain').send('');
    }
    const content = fs.readFileSync(filePath, 'utf8');
    res.type('text/plain').send(content);
  } catch (err: unknown) {
    res.status(500).json({ error: (err as Error).message });
  }
});

// PUT /api/plugins/credit-text?path=data/Credits.txt - Save credit text file
router.put('/credit-text', express.text({ type: '*/*' }), (req: Request, res: Response) => {
  try {
    const filePath = resolveCreditFilePath((req.query.path as string) || 'data/Credits.txt');
    if (!filePath) return res.status(403).json({ error: 'Access denied' });
    fs.mkdirSync(path.dirname(filePath), { recursive: true });
    fs.writeFileSync(filePath, req.body, 'utf8');
    res.json({ success: true });
  } catch (err: unknown) {
    res.status(500).json({ error: (err as Error).message });
  }
});

// POST /api/plugins/credit-text/open-folder?path=data/Credits.txt - Open containing folder
router.post('/credit-text/open-folder', (req: Request, res: Response) => {
  try {
    const filePath = resolveCreditFilePath((req.query.path as string) || 'data/Credits.txt');
    if (!filePath) return res.status(403).json({ error: 'Access denied' });
    const dirPath = fs.existsSync(filePath) ? path.dirname(filePath) : path.dirname(filePath);
    const cmd = process.platform === 'darwin' ? `open "${dirPath}"`
      : process.platform === 'win32' ? `explorer "${dirPath}"`
      : `xdg-open "${dirPath}"`;
    exec(cmd);
    res.json({ success: true });
  } catch (err: unknown) {
    res.status(500).json({ error: (err as Error).message });
  }
});

// GET /api/plugins/browse-dir?dir=img/skybox - List subdirectories within a project directory
router.get('/browse-dir', (req: Request, res: Response) => {
  try {
    const dir = (req.query.dir as string) || '';
    const basePath = projectManager.currentPath!;
    const targetPath = path.join(basePath, dir);

    // Security: prevent path traversal
    const resolved = path.resolve(targetPath);
    if (!resolved.startsWith(path.resolve(basePath))) {
      return res.status(403).json({ error: 'Access denied' });
    }

    if (!fs.existsSync(targetPath)) {
      return res.json({ dirs: [] });
    }

    const entries = fs.readdirSync(targetPath, { withFileTypes: true });
    const dirs = entries
      .filter(e => e.isDirectory() && !e.name.startsWith('.'))
      .map(e => e.name)
      .sort();
    res.json({ dirs });
  } catch (err: unknown) {
    res.status(500).json({ error: (err as Error).message });
  }
});

// GET /api/plugins/browse-files?dir=img/skybox&ext=png - List files within a project directory
router.get('/browse-files', (req: Request, res: Response) => {
  try {
    const dir = (req.query.dir as string) || '';
    const ext = (req.query.ext as string) || '';
    const basePath = projectManager.currentPath!;
    const targetPath = path.join(basePath, dir);

    // Security: prevent path traversal
    const resolved = path.resolve(targetPath);
    if (!resolved.startsWith(path.resolve(basePath))) {
      return res.status(403).json({ error: 'Access denied' });
    }

    if (!fs.existsSync(targetPath)) {
      return res.json({ files: [] });
    }

    const entries = fs.readdirSync(targetPath, { withFileTypes: true });
    let files = entries
      .filter(e => e.isFile() && !e.name.startsWith('.'))
      .map(e => e.name);

    if (ext) {
      const exts = ext.split(',').map(e => '.' + e.toLowerCase());
      files = files.filter(f => exts.some(e => f.toLowerCase().endsWith(e)));
    }

    res.json({ files: files.sort() });
  } catch (err: unknown) {
    res.status(500).json({ error: (err as Error).message });
  }
});

// GET /api/plugins/core-metadata - Parse metadata from editor core JS files (non-plugin folder)
// These are files like FogOfWar.js, Mode3D.js, ShadowAndLight.js, PostProcess.js, rpg_sprites.js
// that implement plugin commands but live in runtime/js/ root, not in a plugins/ folder.
router.get('/core-metadata', (_req: Request, res: Response) => {
  try {
    const coreDir = path.join(runtimePath, 'js');
    // Only scan files directly in the runtime/js/ root (not subfolders)
    const coreFiles = fs.readdirSync(coreDir, { withFileTypes: true })
      .filter(e => e.isFile() && e.name.endsWith('.js'))
      .map(e => e.name);

    const result: Record<string, PluginMetadata> = {};

    for (const file of coreFiles) {
      const content = fs.readFileSync(path.join(coreDir, file), 'utf8');
      const baseName = file.replace('.js', '');

      // 파일 내 모든 /*: ... */ 블록을 추출하여 각각 파싱
      // 같은 파일에 여러 @plugincommand 블록이 있을 경우 각각을 독립 엔트리로 등록
      const allBlocks = content.match(/\/\*:[\s\S]*?\*\//g) || [];
      let blockIndex = 0;
      for (const rawBlock of allBlocks) {
        const meta = parsePluginMetadata(rawBlock);
        if (!meta.commands || meta.commands.length === 0) continue;
        // 엔트리 키: 첫 블록은 파일명, 추가 블록은 plugincommand 값 또는 파일명+인덱스
        const entryKey = blockIndex === 0
          ? baseName
          : (meta.plugincommand || `${baseName}_${blockIndex}`);
        result[entryKey] = meta;
        blockIndex++;
      }
    }

    res.json(result);
  } catch (err: unknown) {
    res.status(500).json({ error: (err as Error).message });
  }
});

// GET /api/plugins/editor-plugins - List editor-provided plugins with update status
router.get('/editor-plugins', (req: Request, res: Response) => {
  try {
    const editorPluginsDir = path.join(runtimePath, 'js', 'plugins');
    if (!fs.existsSync(editorPluginsDir)) return res.json([]);

    const projectPluginsDir = path.join(projectManager.getJsPath(), 'plugins');
    const epFiles = fs.readdirSync(editorPluginsDir).filter(f => f.endsWith('.js'));
    const result: { name: string; hasUpdate: boolean }[] = [];

    for (const epFile of epFiles) {
      const name = epFile.replace('.js', '');
      const editorFile = path.join(editorPluginsDir, epFile);
      const projectFile = path.join(projectPluginsDir, epFile);
      let hasUpdate = false;
      if (fs.existsSync(projectFile)) {
        hasUpdate = pluginFileHash(editorFile) !== pluginFileHash(projectFile);
      } else {
        hasUpdate = true; // not yet copied
      }
      result.push({ name, hasUpdate });
    }

    res.json(result);
  } catch (err: unknown) {
    res.status(500).json({ error: (err as Error).message });
  }
});

// POST /api/plugins/upgrade - Upgrade an editor plugin to latest version
router.post('/upgrade', (req: Request, res: Response) => {
  try {
    const { name } = req.body;
    if (!name) return res.status(400).json({ error: 'name is required' });

    const editorFile = path.join(runtimePath, 'js', 'plugins', `${name}.js`);
    if (!fs.existsSync(editorFile)) {
      return res.status(404).json({ error: `Editor plugin not found: ${name}` });
    }

    const projectPluginsDir = path.join(projectManager.getJsPath(), 'plugins');
    fs.mkdirSync(projectPluginsDir, { recursive: true });
    const dest = path.join(projectPluginsDir, `${name}.js`);
    fs.copyFileSync(editorFile, dest);

    res.json({ success: true });
  } catch (err: unknown) {
    res.status(500).json({ error: (err as Error).message });
  }
});

export default router;
