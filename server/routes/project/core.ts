import express, { Request, Response } from 'express';
import fs from 'fs';
import path from 'path';
import { exec } from 'child_process';
import sharp from 'sharp';
import projectManager from '../../services/projectManager';
import fileWatcher from '../../services/fileWatcher';
import { openInExplorer, openInTerminal } from './helpers';
import { setupSSE, sseWrite } from './deploy';

/** img/ 폴더에 .webp 파일이 하나라도 있으면 true */
function hasWebpImages(projectPath: string): boolean {
  const imgDir = path.join(projectPath, 'img');
  if (!fs.existsSync(imgDir)) return false;
  function check(dir: string): boolean {
    for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
      if (entry.isDirectory()) { if (check(path.join(dir, entry.name))) return true; }
      else if (entry.name.toLowerCase().endsWith('.webp')) return true;
    }
    return false;
  }
  return check(imgDir);
}

const router = express.Router();

router.post('/open', (req: Request, res: Response) => {
  try {
    const { path: projectPath } = req.body;
    if (!projectPath) {
      return res.status(400).json({ error: 'path is required' });
    }

    // RPG Maker MV에서 한번도 실행되지 않은 프로젝트 체크 (js/rpg_core.js 없으면 미실행)
    const rpgCoreFile = path.join(projectPath, 'js', 'rpg_core.js');
    if (!fs.existsSync(rpgCoreFile)) {
      return res.status(400).json({
        errorCode: 'NOT_INITIALIZED',
        error: 'RPG Maker MV에서 한번도 실행되지 않은 프로젝트입니다.',
      });
    }

    projectManager.open(projectPath);
    fileWatcher.watch(projectManager.getDataPath());

    const system = projectManager.readJSON('System.json') as { gameTitle?: string };
    const mapInfos = projectManager.readJSON('MapInfos.json');
    const name = system.gameTitle || path.basename(projectPath);

    // MadeWithMv 플러그인 최초 열기 시 비활성화 (project_ext.json 플래그로 관리)
    const projectExtPath = path.join(projectPath, 'data', 'project_ext.json');
    let projectExt: Record<string, unknown> = {};
    try {
      if (fs.existsSync(projectExtPath)) {
        projectExt = JSON.parse(fs.readFileSync(projectExtPath, 'utf8'));
      }
    } catch { /* ignore */ }

    if (!projectExt.madeWithMvDisabled) {
      try {
        const pluginsJsPath = path.join(projectPath, 'js', 'plugins.js');
        if (fs.existsSync(pluginsJsPath)) {
          const content = fs.readFileSync(pluginsJsPath, 'utf8');
          const match = content.match(/\$plugins\s*=\s*(\[[\s\S]*?\]);/);
          if (match) {
            const pluginList: { name: string; status: boolean; description: string; parameters: Record<string, string> }[] = JSON.parse(match[1]);
            const idx = pluginList.findIndex(p => p.name === 'MadeWithMv');
            if (idx >= 0 && pluginList[idx].status === true) {
              pluginList[idx] = { ...pluginList[idx], status: false };
              const lines = pluginList.map(p => JSON.stringify(p));
              const newContent = `// Generated by RPG Maker.\n// Do not edit this file directly.\nvar $plugins =\n[\n${lines.join(',\n')}\n];\n`;
              fs.writeFileSync(pluginsJsPath, newContent, 'utf8');
            }
          }
        }
      } catch { /* ignore */ }
      projectExt.madeWithMvDisabled = true;
      try {
        fs.writeFileSync(projectExtPath, JSON.stringify(projectExt, null, 2), 'utf8');
      } catch { /* ignore */ }
    }

    // Validate all data JSON files
    const parseErrors: { file: string; error: string }[] = [];
    const dataDir = projectManager.getDataPath();
    try {
      const files = fs.readdirSync(dataDir).filter(f => f.endsWith('.json'));
      for (const file of files) {
        try {
          const raw = fs.readFileSync(path.join(dataDir, file), 'utf8');
          JSON.parse(raw);
        } catch (e) {
          parseErrors.push({ file, error: (e as Error).message });
        }
      }
    } catch { /* data dir read error - ignore */ }

    const useWebp = hasWebpImages(projectPath);
    res.json({ path: projectPath, name, system, mapInfos, useWebp, parseErrors: parseErrors.length > 0 ? parseErrors : undefined });
  } catch (err: unknown) {
    res.status(500).json({ error: (err as Error).message });
  }
});

router.get('/info', (req: Request, res: Response) => {
  if (!projectManager.isOpen()) {
    return res.status(404).json({ error: 'No project open' });
  }
  res.json({ path: projectManager.currentPath });
});

router.post('/close', (req: Request, res: Response) => {
  fileWatcher.stop();
  projectManager.close();
  res.json({ success: true });
});

router.post('/new', (req: Request, res: Response) => {
  try {
    const { name, gameTitle, path: projectPath } = req.body;
    if (!name || !projectPath) {
      return res.status(400).json({ error: 'name and path are required' });
    }

    const fullPath = path.join(projectPath, name);
    const dirs = [
      'data',
      'img', 'img/characters', 'img/faces', 'img/tilesets', 'img/parallaxes',
      'img/battlebacks1', 'img/battlebacks2', 'img/enemies', 'img/sv_actors',
      'img/sv_enemies', 'img/system', 'img/titles1', 'img/titles2',
      'img/animations', 'img/pictures',
      'audio', 'audio/bgm', 'audio/bgs', 'audio/me', 'audio/se',
      'js', 'js/plugins',
    ];

    for (const dir of dirs) {
      fs.mkdirSync(path.join(fullPath, dir), { recursive: true });
    }

    // Default System.json
    const system = {
      gameTitle: gameTitle || name,
      versionId: 1,
      locale: 'en_US',
      partyMembers: [1],
      currencyUnit: 'G',
      windowTone: [0, 0, 0, 0],
      attackMotions: [],
      elements: ['', 'Physical', 'Fire', 'Ice', 'Thunder', 'Water', 'Earth', 'Wind', 'Light', 'Dark'],
      switches: ['', ''],
      variables: ['', ''],
    };
    fs.writeFileSync(path.join(fullPath, 'data', 'System.json'), JSON.stringify(system, null, 2));

    // Default MapInfos.json
    const mapInfos = [null, { id: 1, expanded: false, name: 'MAP001', order: 1, parentId: 0, scrollX: 0, scrollY: 0 }];
    fs.writeFileSync(path.join(fullPath, 'data', 'MapInfos.json'), JSON.stringify(mapInfos, null, 2));

    // Default Map001.json
    const map001 = {
      autoplayBgm: false, autoplayBgs: false, battleback1Name: '', battleback2Name: '',
      bgm: { name: '', pan: 0, pitch: 100, volume: 90 },
      bgs: { name: '', pan: 0, pitch: 100, volume: 90 },
      disableDashing: false, displayName: '', encounterList: [], encounterStep: 30,
      height: 13, note: '', parallaxLoopX: false, parallaxLoopY: false,
      parallaxName: '', parallaxShow: true, parallaxSx: 0, parallaxSy: 0,
      scrollType: 0, specifyBattleback: false, tilesetId: 1, width: 17,
      data: new Array(17 * 13 * 6).fill(0),
      events: [null],
    };
    fs.writeFileSync(path.join(fullPath, 'data', 'Map001.json'), JSON.stringify(map001, null, 2));

    // Default data files
    const defaults: Record<string, unknown> = {
      'Actors.json': [null, { id: 1, battlerName: '', characterIndex: 0, characterName: '', classId: 1, equips: [0, 0, 0, 0, 0], faceIndex: 0, faceName: '', traits: [], initialLevel: 1, maxLevel: 99, name: 'Actor1', nickname: '', note: '', profile: '' }],
      'Classes.json': [null, { id: 1, expParams: [30, 20, 30, 30], traits: [], learnings: [], name: 'Class1', note: '', params: [[300,300],[100,100],[30,30],[30,30],[30,30],[30,30],[30,30],[30,30]] }],
      'Skills.json': [null],
      'Items.json': [null],
      'Weapons.json': [null],
      'Armors.json': [null],
      'Enemies.json': [null],
      'Troops.json': [null],
      'States.json': [null],
      'Animations.json': [null],
      'Tilesets.json': [null, { id: 1, mode: 1, name: 'Tileset', note: '', tilesetNames: ['', '', '', '', '', '', '', '', ''], flags: [] }],
      'CommonEvents.json': [null],
    };
    for (const [filename, data] of Object.entries(defaults)) {
      fs.writeFileSync(path.join(fullPath, 'data', filename), JSON.stringify(data, null, 2));
    }

    // Game.rpgproject marker
    fs.writeFileSync(path.join(fullPath, 'Game.rpgproject'), 'RPGMV 1.6.2');

    res.json({ path: fullPath, name });
  } catch (err: unknown) {
    res.status(500).json({ error: (err as Error).message });
  }
});

router.post('/open-folder', (req: Request, res: Response) => {
  if (!projectManager.isOpen()) {
    return res.status(404).json({ error: 'No project open' });
  }
  const subfolder = req.body?.subfolder;
  let targetPath = projectManager.currentPath!;
  if (subfolder) {
    const resolved = path.join(targetPath, subfolder);
    if (fs.existsSync(resolved)) targetPath = resolved;
  }
  openInExplorer(targetPath);
  res.json({ success: true });
});

router.post('/open-folder-terminal', (_req: Request, res: Response) => {
  if (!projectManager.isOpen()) {
    return res.status(404).json({ error: 'No project open' });
  }
  openInTerminal(projectManager.currentPath!);
  res.json({ success: true });
});

router.post('/open-editor-folder', (_req: Request, res: Response) => {
  const editorPath = path.join(__dirname, '..', '..', '..');
  openInExplorer(editorPath);
  res.json({ success: true });
});

router.post('/open-editor-folder-terminal', (_req: Request, res: Response) => {
  const editorPath = path.join(__dirname, '..', '..', '..');
  openInTerminal(editorPath);
  res.json({ success: true });
});

router.post('/open-vscode', (req: Request, res: Response) => {
  if (!projectManager.isOpen()) {
    return res.status(404).json({ error: 'No project open' });
  }
  exec(`code "${projectManager.currentPath}"`);
  res.json({ success: true });
});

router.get('/check-path', (req: Request, res: Response) => {
  const p = req.query.path as string;
  if (!p) return res.status(400).json({ error: 'path is required' });
  const exists = fs.existsSync(p) && fs.existsSync(path.join(p, 'data', 'System.json'));
  res.json({ exists });
});

// Deploy project
router.post('/deploy', (req: Request, res: Response) => {
  try {
    if (!projectManager.isOpen()) {
      return res.status(404).json({ error: 'No project open' });
    }
    const { outputPath } = req.body;
    if (!outputPath) {
      return res.status(400).json({ error: 'outputPath is required' });
    }

    const srcPath = projectManager.currentPath!;
    const destPath = path.resolve(outputPath);

    // Recursive copy
    const copyDir = (src: string, dest: string) => {
      fs.mkdirSync(dest, { recursive: true });
      for (const entry of fs.readdirSync(src, { withFileTypes: true })) {
        if (entry.name.startsWith('.')) continue;
        const srcEntry = path.join(src, entry.name);
        const destEntry = path.join(dest, entry.name);
        if (entry.isDirectory()) {
          copyDir(srcEntry, destEntry);
        } else {
          fs.copyFileSync(srcEntry, destEntry);
        }
      }
    };

    copyDir(srcPath, destPath);
    res.json({ success: true, outputPath: destPath });
  } catch (err: unknown) {
    res.status(500).json({ error: (err as Error).message });
  }
});

// ─── PNG → WebP 일괄 변환 (SSE) ──────────────────────────────────────────────
router.get('/convert-webp-progress', async (req: Request, res: Response) => {
  if (!projectManager.isOpen()) {
    res.status(404).json({ error: '프로젝트가 열려있지 않습니다' });
    return;
  }
  const projectPath = projectManager.currentPath!;
  const imgDir = path.join(projectPath, 'img');
  setupSSE(res);

  try {
    if (!fs.existsSync(imgDir)) {
      sseWrite(res, { type: 'done', converted: 0 });
      res.end();
      return;
    }

    // PNG 파일 수집
    const pngFiles: string[] = [];
    function collectPng(dir: string) {
      for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
        const full = path.join(dir, entry.name);
        if (entry.isDirectory()) collectPng(full);
        else if (entry.name.toLowerCase().endsWith('.png')) pngFiles.push(full);
      }
    }
    collectPng(imgDir);

    const total = pngFiles.length;
    sseWrite(res, { type: 'counted', total });
    sseWrite(res, { type: 'log', message: `PNG 파일 ${total}개 변환 시작...` });

    let converted = 0;
    for (const pngPath of pngFiles) {
      const rel = path.relative(imgDir, pngPath);
      sseWrite(res, { type: 'log', message: `  ${rel}` });
      sseWrite(res, { type: 'progress', current: converted, total });
      const webpPath = pngPath.slice(0, -4) + '.webp';
      await sharp(pngPath).webp({ lossless: true }).toFile(webpPath);
      fs.unlinkSync(pngPath);
      converted++;
      sseWrite(res, { type: 'progress', current: converted, total });
    }

    sseWrite(res, { type: 'log', message: `✓ 변환 완료 (${converted}개)` });
    sseWrite(res, { type: 'done', converted });
  } catch (err) {
    sseWrite(res, { type: 'error', message: (err as Error).message });
  }
  res.end();
});

export default router;
